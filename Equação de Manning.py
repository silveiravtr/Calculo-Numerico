# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MWPsIeOVmiPQ7WNB0ksjiAicrsYtaerx
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

#Constantes fornecidas no problema
Q=2.44  #Vazio médio desejado no duto (m³/s)
s=0.0003  #Declividade do duto (adimensional)
n=0.013  #Coeficiente de rugosidade médio do duto (adimensional)

#Função f(h) que representa a equação a ser resolvida
def f(h):
    A=2*h  #Área da seção transversal do duto
    #Raio hidráulico, evitando divisão por zero com np.where
    R=np.where(h>0,(2*h)/(2*h+2),np.inf)
    #Calcula o valor da função f(h)
    resultado=Q-(A*(R**(2/3))*(s**0.5))/n
    #Substitui infinitos e valores muito grandes por NaN
    return np.where(np.isfinite(resultado)&(np.abs(resultado)<1e10),resultado,np.nan)

#Análise gráfica inicial da função f(h)
valores_h=np.linspace(0.01,5,500)  # Gera um intervalo de valores para h
valores_f=f(valores_h)  #Avalia a função f para esses valores de h

plt.figure(figsize=(12,6))  #Cria uma figura para o gráfico
plt.plot(valores_h,valores_f,label='f(h)')  #Plota f(h) versus h
plt.axhline(0,color='gray',linestyle='--')  #Adiciona uma linha horizontal em y=0
plt.xlabel('h(m)')  #Rótulo do eixo x
plt.ylabel('f(h)')  #Rótulo do eixo y
plt.title('Análise Gráfica de f(h)')  #Título do gráfico
plt.legend()  #Adiciona uma legenda
plt.grid(True)  #Adiciona uma grade ao gráfico
plt.ylim(-10,10)  #Ajusta os limites do eixo y para evitar overflow
plt.show()  #Exibe o gráfico

#Método da Bissecção
def metodo_bisseccao(a,b,tol):
    cont_iteracoes=0  #Contador de iterações
    while(b-a)/2>tol:  #Continua até a precisão desejada
        cont_iteracoes+=1  #Incrementa o contador de iterações
        c=(a+b)/2  #Ponto médio do intervalo
        if f(c)==0:  #Verifica se o ponto médio é a raiz
            break
        elif f(a)*f(c)<0:  #Ajusta o intervalo com base no sinal
            b=c
        else:
            a=c
    return c,cont_iteracoes,abs(f(c))  #Retorna a raiz, número de iterações e erro

#Método do Ponto Fixo
def g(h):
    if h<=0:
        return h  #Evita divisão por zero retornando o próprio h
    A=2*h
    R=(2*h)/(2*h+2)
    termo=A*(R**(2/3))*(s**0.5)
    if termo==0:
        return h  #Evita divisão por zero retornando o próprio h
    return (Q*n)/termo

def metodo_ponto_fixo(h0,tol):
    cont_iteracoes=0  #Contador de iterações
    while True:
        cont_iteracoes+=1  #Incrementa o contador de iterações
        h1=g(h0)  #Calcula o próximo valor usando a função de iteração
        if abs(h1-h0)<tol:  #Verifica a condição de parada
            break
        h0=h1  #Atualiza a estimativa inicial
    return h1,cont_iteracoes,abs(f(h1))  #Retorna a raiz, número de iterações e erro

#Método de Newton-Raphson
def df(h):
    A=2
    R=(2*h)/(2*h+2)
    dR_dh=4/((2*h+2)**2)  #Derivada do raio hidráulico
    termo1=(R**(2/3))*(s**0.5)/n
    termo2=(2/3)*(R**(-1/3))*dR_dh*(s**0.5)/n
    return -A*termo1-(2*h)*termo2  #Derivada da função f(h)

def metodo_newton_raphson(h0,tol):
    cont_iteracoes=0  #Contador de iterações
    while True:
        cont_iteracoes+=1  #Incrementa o contador de iterações
        h1=h0-f(h0)/df(h0)  #Atualiza a estimativa usando a fórmula de Newton-Raphson
        if abs(h1-h0)<tol:  #Verifica a condição de parada
            break
        h0=h1  #Atualiza a estimativa inicial
    return h1,cont_iteracoes,abs(f(h1))  #Retorna a raiz, número de iterações e erro

#Método das Secantes
def metodo_secantes(h0,h1,tol):
    cont_iteracoes=0  #Contador de iterações
    while True:
        cont_iteracoes+=1  #Incrementa o contador de iterações
        f0=f(h0)
        f1=f(h1)
        if f1-f0==0:
            break  #Evita divisão por zero
        h2=h1-f1*(h1-h0)/(f1-f0)  #Calcula o próximo valor usando a fórmula das secantes
        if abs(h2-h1)<tol:  #Verifica a condição de parada
            break
        h0,h1=h1,h2  #Atualiza as estimativas
    return h2,cont_iteracoes,abs(f(h2))  #Retorna a raiz, número de iterações e erro

#Estimativas iniciais e tolerância
a,b=0.1,5  #Intervalo para o método da bissecção
h0=0.1  #Estimativa inicial para o método do ponto fixo e Newton-Raphson
h1=5  #Segunda estimativa inicial para o método das secantes
tol=1e-6  #Tolerância para a precisão dos métodos

#Calculando raízes e iterações para cada método
h_bisseccao,iter_bisseccao,erro_bisseccao=metodo_bisseccao(a,b,tol)
h_ponto_fixo,iter_ponto_fixo,erro_ponto_fixo=metodo_ponto_fixo(h0,tol)
h_newton,iter_newton,erro_newton=metodo_newton_raphson(h0,tol)
h_secantes,iter_secantes,erro_secantes=metodo_secantes(h0,h1,tol)

#Resultados finais de cada método
resultados={
    'Método':['Bissecção','Ponto Fixo','Newton-Raphson','Secantes'],
    'Raiz Aproximada (h)':[h_bisseccao,h_ponto_fixo,h_newton,h_secantes],
    'Número de Iterações':[iter_bisseccao,iter_ponto_fixo,iter_newton,iter_secantes],
    'Erro':[erro_bisseccao,erro_ponto_fixo,erro_newton,erro_secantes]
}

#Cria um DataFrame com os resultados
df_resultados=pd.DataFrame(resultados)
print(df_resultados)  #Exibe os resultados

#Funções auxiliares para calcular erros em cada método
def erros_bisseccao(a,b,tol):
    erros=[]
    while(b-a)/2>tol:  #Continua até a precisão desejada
        c=(a+b)/2  #Ponto médio do intervalo
        erros.append(abs(f(c)))  #Adiciona o erro da função
        if f(c)==0:
            break
        elif f(a)*f(c)<0:
            b=c
        else:
            a=c
    return erros

def erros_ponto_fixo(h0,tol):
    erros=[]
    while True:
        h1=g(h0)  #Calcula o próximo valor
        erros.append(abs(f(h1)))  #Adiciona o erro da função
        if abs(h1-h0)<tol:
            break
        h0=h1
    return erros

def erros_newton_raphson(h0,tol):
    erros=[]
    while True:
        h1=h0-f(h0)/df(h0)  #Atualiza a estimativa
        erros.append(abs(f(h1)))  #Adiciona o erro da função
        if abs(h1-h0)<tol:
            break
        h0=h1
    return erros

def erros_secantes(h0,h1,tol):
    erros=[]
    while True:
        f0=f(h0)
        f1=f(h1)
        if f1-f0==0:
            break  #Evita divisão por zero
        h2=h1-f1*(h1-h0)/(f1-f0)  #Calcula o próximo valor
        erros.append(abs(f(h2)))  #Adiciona o erro da função
        if abs(h2-h1)<tol:
            break
        h0,h1=h1,h2
    return erros

#Calculando erros para cada método
erros_bisseccao=erros_bisseccao(a,b,tol)
erros_ponto_fixo=erros_ponto_fixo(h0,tol)
erros_newton_raphson=erros_newton_raphson(h0,tol)
erros_secantes=erros_secantes(h0,h1,tol)

#Plotando erros
plt.figure(figsize=(12,8))

plt.plot(range(1,len(erros_bisseccao)+1),erros_bisseccao,label='Bissecção')  #Plot para Bissecção
plt.plot(range(1,len(erros_ponto_fixo)+1),erros_ponto_fixo,label='Ponto Fixo')  #Plot para Ponto Fixo
plt.plot(range(1,len(erros_newton_raphson)+1),erros_newton_raphson,label='Newton-Raphson')  #Plot para Newton-Raphson
plt.plot(range(1,len(erros_secantes)+1),erros_secantes,label='Secantes')  #Plot para Secantes

plt.xlabel('Número de Iterações')  #Rótulo do eixo x
plt.ylabel('Erro')  #Rótulo do eixo y
plt.title('Iterações versus Erro')  #Título do gráfico
plt.legend()  #Adiciona uma legenda
plt.yscale('log')  #Usa escala logarítmica para o eixo y
plt.grid(True)  #Adiciona uma grade ao gráfico
plt.show()  #Exibe o gráfico