# -*- coding: utf-8 -*-
"""Método da Bisseção.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iz3YCosqFbDvreFszI1FcZSUuHTes-4G
"""

'''
Aluno: João Vítor B. Silveira

Método: Método da Bisseção

Resumo: Queremos encontras as raízes de uma equação numéricamente pelo método da
bisseção, que consiste em escolher duas estimativas que delimitam a raiz dentro
de um intervalo. Se a raiz mudar de sinal aplicada nessas duas estimativas,
significa que a raiz está dentro do intervalo. Iterativamente calculamos o ponto
médio e verificamos o erro.

'''


#Importar pacote de funções matemáticas
import numpy as np


#Definir a função que queremos encontrar a raiz

m= 68.1 #Massa do Paraquedista
g= 9.81 #Aceleração Gravitacional
t= 10 #Instante de Tempo
v= 40 #velocidade

def f(c): #coeficiente de arrasto
  return (g*m/c)-(1*np.exp(-(c/m))*t)-v


#Definir uma função para implementar o método da bisseção
#Função a ser resolvida
#Intervalos iniciais e finais
#Tolerância
#N° máximo de iterações

def bissecao(f, xl, xu, tol, max_iter):
  iter=0 #Inicializando um contador de nome iter
  while iter < max_iter: #Enquanto iter for menor que o n° máximo de iterações
    xr= (xl+xu)/2 #Calculando o ponto médio
    fxr= f(xr) #calculando o valor da função no ponto médio

    if abs(fxr) < tol: #Verifica se a tolerância foi satisfeita
      return xr

    if f(xl)* fxr < 0: #Atualiza xu ou x1 baseado no sinal f(xl)*f(xr)<0
      xu=xr
    else:
      xl=xr #Está no intervalo superior

    iter = iter+1
  return xr


#Intervalo inicial:
xl= 12
xu= 16

tol= 0.01 #tolerância desejada
max_iter= 100 #N° máximo de iterações



#Aplicar o método da bisseção

raiz= bissecao(f, xl, xu, tol, max_iter)


#Imprimir o valor da raiz

print("A raiz aproximada é: ", raiz)